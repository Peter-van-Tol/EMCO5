/* Autogenerated by /opt/linuxcnc/bin/halcompile on Fri Mar 10 14:01:52 2023 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:emco5_mpg:EMCO5: Connect the handwheel and speed selector on the userpanel");
MODULE_INFO(linuxcnc, "pin:jogscale-##:float:(16, '( personality & 0xf )'):in:Stepsize when NN is selected:None:None");
MODULE_INFO(linuxcnc, "pin:jogscale-##-selected:bit:(16, '( personality & 0xf )'):in:Should be set HIGH when stepsize NN is to be selected:None:None");
MODULE_INFO(linuxcnc, "pin:jogscale-out:float:0:out:The actual jog-scale, determined on the selected jog-scale and the scale of the integrated ilowpass function:None:None");
MODULE_INFO(linuxcnc, "pin:counts-in:s32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:counts-out:s32:0:out:\\fBcounts-out\\fR tracks \\fBcounts-in\\fR*\\fBscale\\fR through a low-pass filter of \\fBgain\\fR per period.:None:None");
MODULE_INFO(linuxcnc, "param:scale:float:0:rw:A scale factor applied to the output value of the low-pass filter.:1024:None");
MODULE_INFO(linuxcnc, "param:gain:float:0:rw:Together with the period, sets the rate at\n    which the output changes.  Useful range is between 0 and 1, with higher\n    values causing the input value to be tracked more quickly.  For\n    instance, a setting of 0.9 causes the output value to go 90% of the way\n    towards the input value in each period:.5:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "descr:\n    Used for the MPG section of the user panel. Minimizing the number of components\n    required to get the MPG working. Implements ilowpass with a few upgrades. Scaling\n    the ilowpass directly also modifies the step scale for the jogging.\n");
MODULE_INFO(linuxcnc, "author:Peter van Tol <petertgvantol@gmail.com>");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    int _personality;
    hal_float_t *jogscale[16];
    hal_bit_t *jogscale_selected[16];
    hal_float_t *jogscale_out;
    hal_s32_t *counts_in;
    hal_s32_t *counts_out;
    hal_float_t scale;
    hal_float_t gain;
    double value;

    float scale_prev;

    float scale_inv;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg, long personality) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_personality = personality;
    if((( personality & 0xf )) > (16)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin jogscale-##: Requested size %d exceeds max size %d\n",(int)( personality & 0xf ), (int)16);
        return -ENOSPC;
    }
    for(j=0; j < (( personality & 0xf )); j++) {
        r = hal_pin_float_newf(HAL_IN, &(inst->jogscale[j]), comp_id,
            "%s.jogscale-%02d", prefix, j);
        if(r != 0) return r;
    }
    if((( personality & 0xf )) > (16)) {
        rtapi_print_msg(RTAPI_MSG_ERR,"Pin jogscale-##-selected: Requested size %d exceeds max size %d\n",(int)( personality & 0xf ), (int)16);
        return -ENOSPC;
    }
    for(j=0; j < (( personality & 0xf )); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->jogscale_selected[j]), comp_id,
            "%s.jogscale-%02d-selected", prefix, j);
        if(r != 0) return r;
    }
    r = hal_pin_float_newf(HAL_OUT, &(inst->jogscale_out), comp_id,
        "%s.jogscale-out", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(inst->counts_in), comp_id,
        "%s.counts-in", prefix);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(inst->counts_out), comp_id,
        "%s.counts-out", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->scale), comp_id,
        "%s.scale", prefix);
    inst->scale = 1024;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->gain), comp_id,
        "%s.gain", prefix);
    inst->gain = .5;
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int personality[64] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
RTAPI_MP_ARRAY_INT(personality, 64, "personality of each emco5_mpg");

            static int p_value(char* cname, char *name, int idx) {
                int ans = personality[idx%64];
                if (idx >= 64) {
            

                    if (name==NULL) {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: instance %d assigned personality=%d(=%#0x)\n",
                                        cname, idx, ans, ans);
                    } else {
                        rtapi_print_msg(RTAPI_MSG_ERR,"%s: name %s assigned personality=%d(=%#0x)\n",
                                        cname, name, ans, ans);
                    }
                }
                return ans;
            }
            
int rtapi_app_main(void) {
    int r = 0;
    comp_id = hal_init("emco5_mpg");
    if(comp_id < 0) return comp_id;
    r = export("emco5-mpg", 0, personality[0]);
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef jogscale
#define jogscale(i) (0+*(__comp_inst->jogscale[i]))
#undef jogscale_selected
#define jogscale_selected(i) (0+*(__comp_inst->jogscale_selected[i]))
#undef jogscale_out
#define jogscale_out (*__comp_inst->jogscale_out)
#undef counts_in
#define counts_in (0+*__comp_inst->counts_in)
#undef counts_out
#define counts_out (*__comp_inst->counts_out)
#undef scale
#define scale (__comp_inst->scale)
#undef gain
#define gain (__comp_inst->gain)
#undef value
#define value (__comp_inst->value)
#undef scale_prev
#define scale_prev (__comp_inst->scale_prev)
#undef scale_inv
#define scale_inv (__comp_inst->scale_inv)
#undef personality
#define personality (__comp_inst->_personality)


FUNCTION(_) {
#line 37 "emco5_mpg.comp"
// memoisation of scale
if (scale != scale_prev) {
    scale = scale_prev;
    scale_inv = 1.0 / scale;
}

// jog-scale selection
jogscale_out = 0 
for(size_t i=0; i < (personality & 0xf); i++) {
    if(jogscale_selected(i)) { 
        jogscale_out = jogscale(i) * scale_inv;
        break;
    }
}

// ilowpass implementation
// source: https://github.com/robEllenberg/linuxcnc-mirror/blob/master/src/hal/components/ilowpass.comp 
value += (counts_in - value) * gain;
counts_out = (int)(__s64)(value * scale);
}

static int __comp_get_data_size(void) { return 0; }
